# Compare: Go GoClaw Spec/PDR vs Rust Reference (`reference/goclaw`)

## Executive Summary
- Our queue contract is materially stricter than the Rust reference: we require atomic lease claims and explicit DLQ/idempotency; Rust uses in-memory scheduling and async best-effort persistence. [SPEC §5.4: "Task claim MUST be atomic and lease-based"; PDR §6.1: "atomic claim, heartbeat leases"; `/Users/basket/workspace/go-claw/reference/goclaw/src/agent/scheduler.rs:45-56`; `/Users/basket/workspace/go-claw/reference/goclaw/src/agent/worker.rs:82-95`; `/Users/basket/workspace/go-claw/reference/goclaw/src/agent/worker.rs:517-524`]
- Our ACP contract is stronger than Rust web messaging: we require JSON-RPC, negotiated versions, replay cursors, ordered event IDs, and deterministic backpressure close; Rust uses typed WS/SSE events without JSON-RPC/event IDs/replay cursor contracts. [SPEC §5.5: "payloads MUST conform to JSON-RPC 2.0"; PDR §6.3: "ordered replayable event stream"; `/Users/basket/workspace/go-claw/reference/goclaw/src/channels/web/types.rs:426-477`; `/Users/basket/workspace/go-claw/reference/goclaw/src/channels/web/sse.rs:25-27`; `/Users/basket/workspace/go-claw/reference/goclaw/src/channels/web/sse.rs:53-71`]
- Rust is stronger in concrete capability hardening for WASM (allowlist, resource limits, credential redaction/injection), and we should preserve that level of rigor. [PDR §6.5: "Centralize authorization with PDP/PEP model"; `/Users/basket/workspace/go-claw/reference/goclaw/src/tools/wasm/allowlist.rs:95-153`; `/Users/basket/workspace/go-claw/reference/goclaw/src/tools/wasm/wrapper.rs:159-166`; `/Users/basket/workspace/go-claw/reference/goclaw/src/tools/wasm/wrapper.rs:264-266`; `/Users/basket/workspace/go-claw/reference/goclaw/src/tools/wasm/limits.rs:9-17`]
- Rust’s internal worker auth model (per-job bearer tokens) is objectively better than a single static token model and should be adopted as a seam now. [`/Users/basket/workspace/go-claw/reference/goclaw/src/orchestrator/auth.rs:20-49`; `/Users/basket/workspace/go-claw/reference/goclaw/src/orchestrator/auth.rs:79-105`]
- Rust has a major mismatch with our v0.1 deployment goals: it depends on PostgreSQL + containerized subsystems; our contract requires single-binary local operation. [SPEC §2.1: "single executable artifact"; PDR §6.1 context: "single-binary local deployment"; `/Users/basket/workspace/go-claw/reference/goclaw/Cargo.toml:23-27`; `/Users/basket/workspace/go-claw/reference/goclaw/src/history/store.rs:1-7`]
- Rust’s web auth accepts query token fallback and even logs the tokenized URL; that is a practical leakage risk and should not be copied. [`/Users/basket/workspace/go-claw/reference/goclaw/src/channels/web/auth.rs:16-41`; `/Users/basket/workspace/go-claw/reference/goclaw/src/main.rs:1000-1005`]
- Rust drops lagged SSE/broadcast events silently; this is acceptable for best-effort UX but incompatible with our replay correctness claims. [SPEC §5.5: "if cursor is too old, server MUST return explicit replay-gap error"; `/Users/basket/workspace/go-claw/reference/goclaw/src/channels/web/sse.rs:25-27`; `/Users/basket/workspace/go-claw/reference/goclaw/src/channels/web/sse.rs:53-54`]
- Rust skill lifecycle is operationally useful but not fully deterministic: metadata extraction uses placeholders/TODO and activation is direct load, not staged commit/rollback. [SPEC §5.7: "Hot reload MUST be two-phase"; PDR §6.4: "two-phase hot reload and rollback"; `/Users/basket/workspace/go-claw/reference/goclaw/src/tools/wasm/runtime.rs:233-248`; `/Users/basket/workspace/go-claw/reference/goclaw/src/extensions/manager.rs:929-943`]
- Rust security controls are strong but fragmented (web auth middleware, orchestrator auth, safety regex policy, WASM allowlist), while our architecture explicitly requires central PDP semantics; keep Rust mechanisms, not Rust fragmentation. [SPEC §5.8: "centralized PDP contract"; `/Users/basket/workspace/go-claw/reference/goclaw/src/channels/web/auth.rs:20-49`; `/Users/basket/workspace/go-claw/reference/goclaw/src/orchestrator/auth.rs:85-105`; `/Users/basket/workspace/go-claw/reference/goclaw/src/safety/policy.rs:93-121`]
- Rust’s feature surface (extensions discovery, multi-channel integrations, web UI control plane, containers, routines) is powerful but exactly the kind of glue growth our scope rules are trying to prevent. [PDR §10.3: "No new execution substrate in v0.1"; `/Users/basket/workspace/go-claw/reference/goclaw/src/lib.rs:41-61`; `/Users/basket/workspace/go-claw/reference/goclaw/src/extensions/discovery.rs:32-47`]

## Rust Reference Architecture Map

### High-level module map (what exists)
- Entrypoints:
  - Binary runtime and channel orchestration in `/Users/basket/workspace/go-claw/reference/goclaw/src/main.rs:42-1040`.
  - Library module graph in `/Users/basket/workspace/go-claw/reference/goclaw/src/lib.rs:41-61`.
- Persistence:
  - PostgreSQL pool + migrations via `refinery` in `/Users/basket/workspace/go-claw/reference/goclaw/src/history/store.rs:31-62`.
  - Migration set `V1..V8` in `/Users/basket/workspace/go-claw/reference/goclaw/migrations/`.
- Tasking/runtime:
  - In-memory scheduler/job map in `/Users/basket/workspace/go-claw/reference/goclaw/src/agent/scheduler.rs:45-56`.
  - Worker execution loop and tool execution in `/Users/basket/workspace/go-claw/reference/goclaw/src/agent/worker.rs:98-346`.
  - Context/state machine in `/Users/basket/workspace/go-claw/reference/goclaw/src/context/manager.rs:12-19` and `/Users/basket/workspace/go-claw/reference/goclaw/src/context/state.rs:13-30`.
- Web/protocol:
  - Axum gateway routes in `/Users/basket/workspace/go-claw/reference/goclaw/src/channels/web/server.rs:99-192`.
  - WS event protocol in `/Users/basket/workspace/go-claw/reference/goclaw/src/channels/web/types.rs:426-477`.
  - SSE fanout manager in `/Users/basket/workspace/go-claw/reference/goclaw/src/channels/web/sse.rs:17-37`.
- Security/sandbox:
  - Web bearer middleware in `/Users/basket/workspace/go-claw/reference/goclaw/src/channels/web/auth.rs:20-49`.
  - Worker API per-job auth in `/Users/basket/workspace/go-claw/reference/goclaw/src/orchestrator/auth.rs:20-49`.
  - WASM host allowlist/limits in `/Users/basket/workspace/go-claw/reference/goclaw/src/tools/wasm/allowlist.rs:95-153` and `/Users/basket/workspace/go-claw/reference/goclaw/src/tools/wasm/limits.rs:18-35`.
  - Docker sandbox with optional full-access bypass in `/Users/basket/workspace/go-claw/reference/goclaw/src/sandbox/config.rs:57-71` and `/Users/basket/workspace/go-claw/reference/goclaw/src/sandbox/manager.rs:207-210`.

### Lifecycle/concurrency sketch (Rust reference)
```text
main.rs
  -> load config/session/db/tools/channels
  -> start gateway + optional orchestrator API
  -> run agent loop

Scheduler (in-memory HashMap + tokio tasks)
  schedule(job_id)
    -> transition context to InProgress
    -> spawn worker task

Worker
  -> iterative LLM/tool loop
  -> updates context state
  -> async fire-and-forget DB status/action writes
```
Evidence: `/Users/basket/workspace/go-claw/reference/goclaw/src/main.rs:307-347`, `/Users/basket/workspace/go-claw/reference/goclaw/src/agent/scheduler.rs:80-163`, `/Users/basket/workspace/go-claw/reference/goclaw/src/agent/worker.rs:82-95`, `/Users/basket/workspace/go-claw/reference/goclaw/src/agent/worker.rs:517-524`.

## Comparison Matrix

| Dimension | What our SPEC/PDR says | What Rust reference does (evidence) | Who is right (and why) | What we overlooked | Recommendation |
|---|---|---|---|---|---|
| Task queue semantics | SPEC requires atomic leased claims, heartbeats, retry+DLQ+poison handling. Quote: "Task claim MUST be atomic and lease-based" (SPEC §5.4). PDR selects "atomic claim, heartbeat leases" (PDR §6.1). | Scheduler is in-memory `HashMap<Uuid, ScheduledJob>` with `tokio::spawn`; capacity check only. No durable lease columns/claim transaction path in scheduler. (`/Users/basket/workspace/go-claw/reference/goclaw/src/agent/scheduler.rs:45-56`, `80-93`, `124-139`) | Our contract is correct for correctness and recovery. Rust model is simpler but cannot deliver lease-recovery guarantees. | Need explicit stale-completion rejection by lease token in completion path (not just claim). | Keep SPEC/PDR direction; add an explicit `lease_token` compare-on-complete invariant and test. |
| Exactly-once vs at-least-once | SPEC/PDR are explicit: "Task execution semantics MUST be at-least-once" and side effects at-most-once by idempotency key (SPEC §9, PDR §2). | Worker persistence and event persistence are async fire-and-forget tasks; crashes can desync in-memory execution vs persisted facts. (`/Users/basket/workspace/go-claw/reference/goclaw/src/agent/worker.rs:82-95`, `517-524`; `/Users/basket/workspace/go-claw/reference/goclaw/src/orchestrator/api.rs:243-253`) | Our model is right. Rust behavior implicitly degrades guarantees under crash. | We still need to define commit boundaries for side effects vs task transition in one place. | Add a normative "effect journal write before side-effect dispatch" requirement and evidence gate. |
| Idempotency strategy | SPEC says side-effecting calls "MUST include a stable idempotency key" (SPEC §5.4). PDR: "idempotency keys and dedupe table" (PDR §6.2). | No obvious tool-call idempotency registry in worker scheduling path; dedupe appears in routine/event subsystems, not core job tool execution. (`/Users/basket/workspace/go-claw/reference/goclaw/src/agent/worker.rs:380-545`; `rg` scan in `reference/goclaw/src`) | Our approach is safer for external side effects. | Need protocol-level idempotency key source (ACP request, generated run key, or both). | Add SPEC text requiring key derivation hierarchy and collision rules. |
| Persistence + migrations + backup/restore | V0.1 scope is single-binary local daemon; SQLite durability/recovery required (SPEC §2.1, §5.2). | Rust is Postgres-based with `deadpool-postgres`, `tokio-postgres`, `refinery`; migrations are SQL scripts V1..V8. (`/Users/basket/workspace/go-claw/reference/goclaw/Cargo.toml:23-27`; `/Users/basket/workspace/go-claw/reference/goclaw/src/history/store.rs:31-62`) | For our stated scope, we are right to keep SQLite. Rust approach is better only for multi-tenant/remote scale (currently out-of-scope). | Need a cleaner future seam for optional remote DB mode without touching queue semantics. | Keep SQLite in v0.1; add optional storage adapter seam as v0.3 item. |
| Concurrency control/fairness/cancellation | SPEC requires bounded lanes and fairness aging policy (SPEC §5.4, §5.1). PDR emphasizes bounded concurrency (PDR §4). | Rust enforces a max job count (`max_parallel_jobs`) and stop checks, but no fairness/aging policy across sessions. (`/Users/basket/workspace/go-claw/reference/goclaw/src/agent/scheduler.rs:87-93`; `/Users/basket/workspace/go-claw/reference/goclaw/src/agent/worker.rs:229-235`) | Our requirement set is better for starvation prevention. Rust has practical boundedness but weaker fairness semantics. | Need measurable fairness SLO (not just "prevent starvation"). | Add concrete fairness metrics (`max wait skew`, `aging factor`) to SPEC acceptance tests. |
| Protocol (ACP) ordering/backpressure/reconnect/version/auth | ACP contract requires JSON-RPC framing, handshake, per-session FIFO `event_id`, `from_event_id` replay, deterministic backpressure close (SPEC §5.5; PDR §6.3). | Web protocol is typed WS/SSE with `type` tags and no JSON-RPC envelope, no event IDs/cursor handshake. SSE buffer 256 with dropped lagged events. (`/Users/basket/workspace/go-claw/reference/goclaw/src/channels/web/types.rs:426-477`; `/Users/basket/workspace/go-claw/reference/goclaw/src/channels/web/sse.rs:25-27`; `53-54`) | Our contract is right for correctness. Rust transport is practical but best-effort. | Need explicit queueing policy when per-client buffer fills (drop newest vs oldest before close). | Keep ACP spec; require a model-checked state table for reconnect/backpressure transitions. |
| Skills system: ABI/hot reload/cache | SPEC/PDR require ABI versioning, staged activate/rollback, cache keyed by content hash + ABI (SPEC §5.7; PDR §6.4). | WASM runtime has limits/caching, but metadata extraction is TODO placeholders; activation path is direct load/register. (`/Users/basket/workspace/go-claw/reference/goclaw/src/tools/wasm/runtime.rs:233-248`; `/Users/basket/workspace/go-claw/reference/goclaw/src/extensions/manager.rs:929-943`) | Our lifecycle requirements are stronger and safer. Rust has good mechanics, weaker release discipline. | Need clear ABI compatibility matrix format and rollback provenance in audit logs. | Add SPEC requirement for ABI compatibility table and activation transaction record. |
| Policy/security boundaries (PDP/PEP, SSRF, secrets) | SPEC says centralized PDP, default deny, SSRF constraints, redaction/audit (SPEC §5.8). PDR selects centralized model (PDR §6.5). | Strong local mechanisms exist (allowlist validator, secret encryption/redaction), but enforcement is spread across subsystems. (`/Users/basket/workspace/go-claw/reference/goclaw/src/tools/wasm/allowlist.rs:95-153`; `/Users/basket/workspace/go-claw/reference/goclaw/src/secrets/store.rs:89-125`; `/Users/basket/workspace/go-claw/reference/goclaw/src/channels/web/auth.rs:20-49`; `/Users/basket/workspace/go-claw/reference/goclaw/src/safety/policy.rs:93-121`) | Mixed: Rust is stronger in concrete mechanism depth; our architecture is stronger in governance model. | We need to specify PDP decision schema and mandatory call-sites list. | Keep centralized PDP requirement; borrow Rust’s capability-level controls as required PEP inputs. |
| Observability + replay | SPEC/PDR require trace IDs across run/task/session, replay-grade event history, JSON logs (SPEC §5.9; PDR §6.6). | Rust has tracing and a web log broadcaster ring buffer, but no unified `trace_id/run_id/task_id/session_id` contract in event schema. (`/Users/basket/workspace/go-claw/reference/goclaw/src/main.rs:288-292`; `/Users/basket/workspace/go-claw/reference/goclaw/src/channels/web/log_layer.rs:31-37`; `/Users/basket/workspace/go-claw/reference/goclaw/src/channels/web/types.rs:459-477`) | Our contract is right for incident-grade debugging. Rust has helpful tooling but weaker correlation invariants. | Need explicit correlation-field requiredness matrix per event type. | Add per-event-type schema table + replay completeness test vectors. |
| Operational UX: TUI-first vs web control plane | SPEC/PDR choose operational TUI with ACP parity and no unique business logic in UI (SPEC §5.10; PDR §6.7). | Rust uses substantial web gateway control plane with many API routes and static UI assets. (`/Users/basket/workspace/go-claw/reference/goclaw/src/channels/web/server.rs:104-171`; `173-191`; `/Users/basket/workspace/go-claw/reference/goclaw/src/channels/web/mod.rs:1-15`) | For v0.1 scope control, our choice is right. Rust approach is more user-friendly but bigger attack and maintenance surface. | We need to define the exact remote UI seam boundary now (transport + auth + event APIs only). | Keep TUI-first; freeze remote UI seam as protocol contract, not a feature commitment. |
| Internal auth model | SPEC currently defines local bearer auth for ACP; PDR emphasizes fail-closed policy (SPEC §5.5, §5.8). | Rust worker/orchestrator path uses per-job random tokens and scope validation; web path accepts bearer header or query token. (`/Users/basket/workspace/go-claw/reference/goclaw/src/orchestrator/auth.rs:35-49`; `85-105`; `/Users/basket/workspace/go-claw/reference/goclaw/src/channels/web/auth.rs:16-41`) | Per-job scoped auth is objectively better for future sidecar boundaries; query-token fallback is worse. | We overlooked future-proofing auth semantics for optional child-process/sidecar execution. | Add future-seam requirement: ephemeral per-attempt auth tokens for any out-of-process executor; prohibit token-in-URL by default. |

## Biggest Divergences And Implications
- **Durability philosophy diverges sharply.** Our design assumes crash-safe queue semantics; Rust runtime today assumes in-memory scheduling with async persistence side-effects. This is the single biggest correctness gap if we copied patterns directly.
- **Protocol reliability maturity diverges.** Our ACP contract is a reliability protocol; Rust web messaging is an event transport. If we relax to Rust behavior, we lose deterministic replay and client-state correctness.
- **Security depth vs governance split.** Rust has richer mechanism-level defenses (WASM capabilities, secret handling, job-scoped tokens), but not a single policy decision plane. We should import mechanisms, not architecture fragmentation.
- **Operational scope differs by an order of magnitude.** Rust includes gateway UI, multi-channel integrations, extension discovery, sandbox containers, and orchestrator APIs. That breadth is valuable reference material, but copying it would violate our anti-bloat constraints.
- **Data substrate mismatch is fundamental.** Rust’s Postgres dependency conflicts with our single-binary local goal; this is not a minor implementation difference, it is a product posture difference.
- **Auth hygiene gap is concrete.** Query-token acceptance and startup logging of tokenized URLs are operationally dangerous patterns and should be explicitly banned in our contracts.
- **Skill lifecycle is partially solved in Rust, not completed.** Runtime limits/capabilities are strong; ABI/stateful activation guarantees remain under-specified. Our staged/rollback requirements should stay strict.
- **Some Rust complexity is useful seam design.** Per-job scoped auth, capability objects, and clear sandbox policy enums are good design patterns to adopt without adopting full Rust system complexity.

